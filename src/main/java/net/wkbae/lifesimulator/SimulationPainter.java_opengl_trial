package net.wkbae.lifesimulator;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.List;

import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.GLCapabilities;
import javax.media.opengl.GLContext;
import javax.media.opengl.GLDrawableFactory;
import javax.media.opengl.GLOffscreenAutoDrawable;
import javax.media.opengl.GLProfile;

import org.jbox2d.common.MathUtils;
import org.jbox2d.common.Vec2;

public class SimulationPainter {
	private final Simulation simulation;
	
	private final long time;
	
	private final LifePaintInfo[] infos;
	
	SimulationPainter(Simulation simulation, long time, List<LifePaintInfo> info) {
		this(simulation, time, info.toArray(new LifePaintInfo[info.size()]));
	}
	
	SimulationPainter(Simulation simulation, long time, LifePaintInfo[] info) {
		assert(simulation != null && info != null);
		
		this.simulation = simulation;
		this.time = time;
		this.infos = info;
	}
	
	public void paint(Graphics2D g, int size) {
		paint(g, 0, 0, size);
	}
	
	private final static FloatBuffer CIRCLE_VERTEXES;
	private final static int CIRCLE_PARTS = 50;
	
	static {
		if(GLDrawableFactory.getDesktopFactory().canCreateFBO(null, GLProfile.getDefault())) {
			CIRCLE_VERTEXES = ByteBuffer.allocateDirect(4 * (CIRCLE_PARTS+2) * 2).asFloatBuffer();
			CIRCLE_VERTEXES.put(0).put(0);
			for(int i = 0; i <= CIRCLE_PARTS; i++) {
				float angle = i * ((2 * MathUtils.PI) / CIRCLE_PARTS);
				CIRCLE_VERTEXES.put(MathUtils.cos(angle)).put(MathUtils.sin(angle));
			}
			CIRCLE_VERTEXES.flip();
		} else {
			System.out.println("NO PBUFFER");
			CIRCLE_VERTEXES = null;
		}
	}
	
	public void paint(Graphics2D g, int startX, int startY, int size) {
		
		if(CIRCLE_VERTEXES != null) {// && infos.length > 500) {
			System.out.println("Draw GL");
			GLCapabilities cap = new GLCapabilities(GLProfile.getDefault());
			cap.setFBO(true);
			cap.setDoubleBuffered(false);
			GLOffscreenAutoDrawable off = GLDrawableFactory.getDesktopFactory().createOffscreenAutoDrawable(null, cap, null, size, size);
			GLContext ctx = off.createContext(null);
			off.setContext(ctx, true);
			ctx.makeCurrent();
			//GL2 gl = GLContext.getCurrentGL().getGL2();
			//System.out.println(off);
			
			//System.out.println(off.getGL());
			//System.out.println(off.getGL().getGL2());
			GL2 gl = off.getGL().getGL2();
			gl.glDrawBuffer(GL.GL_FRONT);
			
			paintGL(gl, startX, startY, size);
			gl.glBegin(GL.GL_LINE_SMOOTH);
			gl.glVertex2f(0, 0);
			gl.glVertex2f(size, size);
			gl.glEnd();
			
			gl.glFlush();
			gl.glFinish();
			
			gl.glReadBuffer(GL.GL_FRONT);
			
			IntBuffer buf = IntBuffer.allocate(2 * size * size);//ByteBuffer.allocateDirect(4 * 2 * size * size).asIntBuffer();
			gl.glReadPixels(0, 0, size, size, GL.GL_BGRA, GL.GL_UNSIGNED_INT_24_8, buf);
			/*buf.rewind();
			int[] data = new int[size * size];
			for(int i = 0; i < size * size; i++) {
				data[i] = buf.get();
				buf.get();
			}*/
			
			//System.out.println(Arrays.toString(data));
			BufferedImage bi = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
			//bi.setRGB(0, 0, size, size, data, 0, 0);
			bi.setRGB(0, 0, size, size, buf.array(), 0, 1);
			g.drawImage(bi, 0, 0, null);
			ctx.release();
			ctx.destroy();
			off.destroy();
		} else {
			System.out.println("Draw Normal");
			float multiplyer = size * this.simulation.worldSizeReverse;
			
			g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			g.setColor(Color.WHITE);
			g.fillRect(startX, startY, startX+size, startY+size);
			
			for(LifePaintInfo info : infos) {
				//Vec2 loc = info.loc.mul(multiplyer);
				float rad = info.size * multiplyer;
				
				int red = (info.color >> 8) & 0xF;
				int grn = (info.color >> 4) & 0xF;
				int blu = info.color & 0xF;
				g.setColor(new Color(red << 4 | red, grn << 4 | grn, blu << 4 | blu));
				
				int x = MathUtils.round(info.x * multiplyer - rad) + startX;
				int y = MathUtils.round(info.y * multiplyer - rad) + startY;
				int s = MathUtils.round(rad*2);
				g.fillOval(x, y, s, s);
				g.setColor(Color.BLACK);
				g.drawOval(x, y, s, s);
			}
		}
	}
	
	public void paintGL(GL2 gl, int size) {
		paintGL(gl, 0, 0, size);
	}
	
	public void paintGL(GL2 gl, int startX, int startY, int size) {
		float multiplyer = size * this.simulation.worldSizeReverse;
		//System.out.println("[" + gl + "] size: " + size);
		gl.glMatrixMode(GL2.GL_PROJECTION);
		gl.glLoadIdentity();
		
		//GLU glu = new GLU();
		//glu.gluOrtho2D(0.0f, size, 0.0f, size);
		gl.glOrtho(0, size, 0, size, -1, 1);
		
		gl.glMatrixMode(GL2.GL_MODELVIEW);
		gl.glLoadIdentity();
		gl.glViewport(0, 0, size, size);
		
		//gl.glColor3ub((byte)0xFF, (byte)0xFF, (byte)0xFF);		
		/*gl.glBegin(GL2.GL_QUADS);
		gl.glVertex2f(0, 0);
		gl.glVertex2f(0, size);
		gl.glVertex2f(size, size);
		gl.glVertex2f(size, 0);
		gl.glEnd();*/
		//gl.glRectf(0, 0, size, size);
		
		gl.glClearColor(1, 1, 1, 0);
		gl.glClear(GL.GL_COLOR_BUFFER_BIT);
        
		gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
		
		gl.glVertexPointer(2, GL2.GL_FLOAT, 0, CIRCLE_VERTEXES);
		
		for(LifePaintInfo info : infos) {
			float rad = info.size * multiplyer;
			
			int red = (info.color >> 8) & 0xF;
			int grn = (info.color >> 4) & 0xF;
			int blu = info.color & 0xF;
			
			float x = info.x * multiplyer - rad + startX;
			float y = info.y * multiplyer - rad + startY;
			float s = rad*2;
			
			gl.glPushMatrix();
			
			gl.glTranslatef(x, y, 0);
			gl.glScalef(s, s, 0);
			
			gl.glColor3ub((byte)((red << 4) | red), (byte)((grn << 4) | grn), (byte)((blu << 4) | blu));
			gl.glDrawArrays(GL2.GL_TRIANGLE_FAN, 0, CIRCLE_PARTS+2);
			
			gl.glColor3ub((byte)0, (byte)0, (byte)0);
			gl.glDrawArrays(GL2.GL_LINES, 1, CIRCLE_PARTS+1);
			
			gl.glPopMatrix();
		}
		gl.glDisableClientState(GL2.GL_VERTEX_ARRAY);
		gl.glFlush();
	}
	
	public Simulation getSimulation() {
		return simulation;
	}
	
	public long getTime() {
		return time;
	}
	
	static class LifePaintInfo {
		public final int color;
		public final float size;
		public final float x, y;
		//public final Vec2 loc;
		LifePaintInfo(Lifeform life) {
			//loc = new Vec2(life.getBody().getPosition());
			Vec2 loc = life.getBody().getPosition();
			x = loc.x;
			y = loc.y;
			size = life.getSize();
			color = life.getColor();
			//int re = (color >> 8) & 0xF;
			//int gr = (color >> 4) & 0xF;
			//int bl = color & 0xF;
			//this.color = new Color(re << 4 | re, gr << 4 | gr, bl << 4 | bl);
		}
	}
}